{
  "name" : "Handler",
  "qualifiedName" : "io.fluxzero.common.handling.Handler",
  "packageName" : "io.fluxzero.common.handling",
  "kind" : "interface",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ ],
  "documentation" : " Represents a container for a message handler and the mechanism to resolve a {@link HandlerInvoker} for a given\n message.\n <p>\n A {@code Handler} encapsulates a target class and a provider for an instance of that class. It acts as a factory for\n {@code HandlerInvoker} instances that can be used to invoke the appropriate handler method for a given message.\n </p>\n\n <p>\n This abstraction allows support for both stateless and stateful handlers:\n </p>\n <ul>\n     <li><strong>Stateless:</strong> A singleton handler instance is reused for every message (e.g., typical application service).</li>\n     <li><strong>Stateful:</strong> The handler instance is dynamically retrieved, e.g., from a repository, based on message content (e.g., aggregates or projections).</li>\n </ul>\n\n <p>\n A handler may or may not be able to process a given message. If it can, it returns a non-empty\n {@link Optional} containing a {@link HandlerInvoker}; otherwise, it returns {@code Optional.empty()}.\n </p>\n\n <h2>Handler Architecture</h2>\n <pre>\n ┌────────────────────┐\n │  HandlerInspector  │\n └────────┬───────────┘\n          │ inspects target class\n          ▼\n ┌────────────────────┐        creates        ┌──────────────────────┐\n │  HandlerMatcher    │──────────────────────▶│     HandlerInvoker   │\n └────────┬───────────┘                       └──────────────────────┘\n          │ produces invoker if message\n          │ matches a method\n          ▼\n ┌────────────────────┐\n │      Handler       │◀───────────── target instance\n └────────────────────┘\n </pre>\n\n @param <M> the type of messages this handler supports (usually {@code DeserializingMessage})\n @see HandlerInvoker\n @see HandlerMatcher\n @see HandlerInspector\n",
  "typeParameters" : [ "M" ],
  "superClass" : null,
  "interfaces" : [ ],
  "fields" : [ ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "getInvoker",
    "qualifiedName" : "io.fluxzero.common.handling.Handler#getInvoker",
    "returnType" : "java.util.Optional<io.fluxzero.common.handling.HandlerInvoker>",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "message",
      "type" : "M",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Returns a {@link HandlerInvoker} capable of processing the given message, if available.\n\n @param message the message to be handled\n @return an optional {@code HandlerInvoker} if this handler can handle the message; otherwise\n {@code Optional.empty()}\n"
  }, {
    "name" : "getTargetClass",
    "qualifiedName" : "io.fluxzero.common.handling.Handler#getTargetClass",
    "returnType" : "java.lang.Class<?>",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Returns the class of the handler's target object. This may be used for reflective operations, logging, or\n framework-level behavior.\n\n @return the class of the handler's target\n"
  }, {
    "name" : "or",
    "qualifiedName" : "io.fluxzero.common.handling.Handler#or",
    "returnType" : "io.fluxzero.common.handling.Handler<M>",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "next",
      "type" : "io.fluxzero.common.handling.Handler<M>",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Creates a composite handler that executes the current handler and then delegates to the specified next handler if\n the current handler cannot handle the message or does not provide an invoker.\n\n @param next the next handler to be invoked if this handler does not handle the message\n @return a new handler combining the current handler and the specified next handler\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ {
    "name" : "DelegatingHandler",
    "qualifiedName" : "io.fluxzero.common.handling.Handler$DelegatingHandler",
    "kind" : "class",
    "modifiers" : [ "abstract", "public", "static" ],
    "annotations" : [ {
      "annotationType" : "lombok.AllArgsConstructor",
      "values" : {}
    } ]
  } ]
}
