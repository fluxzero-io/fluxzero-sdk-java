{
  "name" : "ConsistentHashing",
  "qualifiedName" : "io.fluxzero.common.ConsistentHashing",
  "packageName" : "io.fluxzero.common",
  "kind" : "class",
  "modifiers" : [ "public" ],
  "annotations" : [ ],
  "documentation" : " Utility class for computing segment assignments using consistent hashing.\n <p>\n This class maps routing keys to numeric segments using a hash function, typically to support partitioned processing\n or distribution across consumers in Fluxzero.\n\n <p>\n Segments are defined as integer ranges, and a typical range is from 0 (inclusive) to {@code MAX_SEGMENT} (exclusive),\n where {@code MAX_SEGMENT} is defined in {@link Position}.\n\n <h2>Key Features</h2>\n <ul>\n   <li>Computes deterministic segment for a given routing key</li>\n   <li>Supports customizable hash functions</li>\n   <li>Checks if a segment falls within a range</li>\n   <li>Detects whether a segment range is empty</li>\n </ul>\n",
  "typeParameters" : [ ],
  "superClass" : "java.lang.Object",
  "interfaces" : [ ],
  "fields" : [ {
    "name" : "defaultHashFunction",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing.defaultHashFunction",
    "type" : "java.util.function.Function<java.lang.String,java.lang.Integer>",
    "modifiers" : [ "final", "private", "static" ],
    "annotations" : [ ],
    "documentation" : " Default hash function used to compute segment index from a routing key. Uses Murmur3 32-bit hash for fast and\n stable hashing.\n",
    "constantValue" : null
  } ],
  "constructors" : [ {
    "name" : "ConsistentHashing",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#ConsistentHashing",
    "modifiers" : [ "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : null
  } ],
  "methods" : [ {
    "name" : "computeSegment",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#computeSegment",
    "returnType" : "int",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "routingKey",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Computes the segment for a given routing key using the default hash function and the default maximum segment size.\n\n @param routingKey the routing key to hash\n @return the segment index\n"
  }, {
    "name" : "computeSegment",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#computeSegment",
    "returnType" : "int",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "routingKey",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "maxSegments",
      "type" : "int",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Computes the segment for a given routing key and maximum number of segments, using the default hash function.\n\n @param routingKey   the routing key to hash\n @param maxSegments  the number of available segments\n @return the segment index\n"
  }, {
    "name" : "computeSegment",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#computeSegment",
    "returnType" : "int",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "routingKey",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "hashFunction",
      "type" : "java.util.function.Function<java.lang.String,java.lang.Integer>",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "maxSegments",
      "type" : "int",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Computes the segment using a custom hash function and max segment size.\n\n @param routingKey    the routing key to hash\n @param hashFunction  a custom hash function\n @param maxSegments   the number of available segments\n @return the segment index\n"
  }, {
    "name" : "fallsInRange",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#fallsInRange",
    "returnType" : "boolean",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "segment",
      "type" : "int",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Checks if a given segment index falls within a specified segment range.\n\n @param segment       the segment index\n @param segmentRange  segment range [start, end)\n @return {@code true} if the segment is within the range\n"
  }, {
    "name" : "fallsInRange",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#fallsInRange",
    "returnType" : "boolean",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "routingKey",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Checks if the segment computed from the routing key falls within the specified segment range.\n\n @param routingKey    the routing key\n @param segmentRange  an array of two integers [start, end)\n @return {@code true} if the segment is within the range\n"
  }, {
    "name" : "fallsInRange",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#fallsInRange",
    "returnType" : "boolean",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "routingKey",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "maxSegments",
      "type" : "int",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Same as {@link #fallsInRange(String, int[])}, but uses a custom max segment size.\n\n @param routingKey    the routing key\n @param segmentRange  segment range [start, end)\n @param maxSegments   number of available segments\n @return {@code true} if the computed segment falls in the range\n"
  }, {
    "name" : "isEmptyRange",
    "qualifiedName" : "io.fluxzero.common.ConsistentHashing#isEmptyRange",
    "returnType" : "boolean",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Checks whether the segment range is empty (i.e., start == end).\n\n @param segmentRange an array of two integers [start, end)\n @return {@code true} if the range is empty\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
