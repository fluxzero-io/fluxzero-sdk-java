{
  "name" : "RegisterType",
  "qualifiedName" : "io.fluxzero.common.serialization.RegisterType",
  "packageName" : "io.fluxzero.common.serialization",
  "kind" : "annotation_type",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ {
    "annotationType" : "java.lang.annotation.Retention",
    "values" : {
      "value" : "CLASS"
    }
  }, {
    "annotationType" : "java.lang.annotation.Target",
    "values" : {
      "value" : "PACKAGE,TYPE"
    }
  }, {
    "annotationType" : "java.lang.annotation.Inherited",
    "values" : {}
  } ],
  "documentation" : " Annotation to register a class or package for inclusion in the {@link TypeRegistry}.\n <p>\n Registered types are used to enable simplified type resolution, for example when deserializing JSON that references a\n type by name or when using {@code TestFixture} helpers to specify input/output types.\n <p>\n If this annotation is placed on a <strong>class</strong>, that class will be registered in the {@code TypeRegistry}.\n If placed on a <strong>package</strong>, all types in that package and its ancestor packages will be registered.\n <p>\n Types or packages marked with {@code @RegisterType} are discovered and indexed during annotation processing. This\n means that they must be available on the classpath at compile time, and annotation processing must be enabled for the\n type registry to function correctly.\n\n <h2>Usage</h2>\n Registered types can be referenced by:\n <ul>\n   <li>Simple class name (e.g., {@code \"Foo\"})</li>\n   <li>Disambiguated name using trailing segments (e.g., {@code \"example.Foo\"})</li>\n </ul>\n <p>\n This is especially useful when a type is referenced in serialized form using the {@code \"@class\"} attribute:\n <pre>{@code\n {\n   \"@class\": \"Foo\",\n   \"name\": \"Example\"\n }\n }</pre>\n <p>\n If multiple classes have the same simple name, Fluxzero will attempt to resolve the type using the shortest suffix\n that still uniquely identifies it (e.g., {@code \"billing.Foo\"} vs. {@code \"shipping.Foo\"}). If conflicts remain,\n the returned type is unpredictable.\n\n <h2>Filtering using {@link #contains()}</h2>\n You can restrict which types are registered by specifying patterns to match against the class name:\n <pre>{@code\n @RegisterType(contains = {\"Dto\", \"Request\"})\n }</pre>\n This ensures that only classes whose names include {@code \"Dto\"} or {@code \"Request\"} will be registered.\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ "java.lang.annotation.Annotation" ],
  "fields" : [ ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.serialization.RegisterType#contains",
    "returnType" : "java.lang.String[]",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Optional filters to determine which types should be registered based on name matching.\n <p>\n If this array is left empty (the default), all types in the annotated class or package are included. If provided,\n a type is only registered if one or more of these regular expressions match the class name.\n\n @return array of regex patterns used to match class names for registration\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
