{
  "name" : "Tracker",
  "qualifiedName" : "io.fluxzero.common.tracking.Tracker",
  "packageName" : "io.fluxzero.common.tracking",
  "kind" : "interface",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ ],
  "documentation" : " A {@code Tracker} represents an active consumer of messages for a particular {@code ConsumerConfiguration}.\n <p>\n Trackers are responsible for handling a range of message segments and coordinating how and when messages are\n delivered from the {@link MessageStore} or other sources. They are typically managed by a {@link TrackingStrategy}.\n\n <p>Each tracker identifies a specific consumer (via {@link #getConsumerName()}) and client instance (via\n {@link #getClientId()}), and may support additional filtering by message type or target.\n\n <h2>Responsibilities</h2>\n A {@code Tracker} is responsible for:\n <ul>\n     <li>Receiving batches of messages via {@link #send(MessageBatch)}</li>\n     <li>Declaring the range of segments it is responsible for</li>\n     <li>Filtering messages by type, target, and segment hash</li>\n     <li>Tracking its last consumed index and activity deadline</li>\n </ul>\n\n <p>Trackers may also participate in client-controlled index tracking, message purging, and deadline-based disconnection.\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ "java.lang.Comparable<io.fluxzero.common.tracking.Tracker>" ],
  "fields" : [ {
    "name" : "comparator",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker.comparator",
    "type" : "java.util.Comparator<io.fluxzero.common.tracking.Tracker>",
    "modifiers" : [ "final", "public", "static" ],
    "annotations" : [ ],
    "documentation" : " Default comparator based on consumer name and tracker ID.\n",
    "constantValue" : null
  } ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "canHandle",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#canHandle",
    "returnType" : "boolean",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "message",
      "type" : "io.fluxzero.common.api.SerializedMessage",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Checks if the given message can be handled by this tracker based on segment range and type filtering.\n\n @param message      the message to check\n @param segmentRange the range of segments this tracker is assigned to\n @return {@code true} if the message is valid for this tracker\n"
  }, {
    "name" : "clientControlledIndex",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#clientControlledIndex",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return {@code true} if this tracker uses client-controlled index tracking (instead of store-side indexing).\n"
  }, {
    "name" : "compareTo",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#compareTo",
    "returnType" : "int",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ {
      "annotationType" : "java.lang.Override",
      "values" : {}
    } ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "o",
      "type" : "io.fluxzero.common.tracking.Tracker",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Compares trackers based on consumer and tracker IDs for stable sorting.\n"
  }, {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#contains",
    "returnType" : "boolean",
    "modifiers" : [ "private" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "message",
      "type" : "io.fluxzero.common.api.SerializedMessage",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Internal helper to check segment inclusion.\n"
  }, {
    "name" : "getClientId",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getClientId",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the unique ID of the client, typically one per client application instance.\n"
  }, {
    "name" : "getConsumerName",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getConsumerName",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the logical name of the consumer this tracker belongs to.\n"
  }, {
    "name" : "getDeadline",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getDeadline",
    "returnType" : "long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the system deadline (epoch millis) by which this tracker expects a new batch. If this deadline is missed,\n the tracker should be given an empty batch.\n"
  }, {
    "name" : "getLastTrackerIndex",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getLastTrackerIndex",
    "returnType" : "java.lang.Long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the index of the last successfully consumed message, or {@code null} if uninitialized.\n"
  }, {
    "name" : "getMaxSize",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getMaxSize",
    "returnType" : "int",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the maximum number of messages this tracker wants to consume in a single batch.\n"
  }, {
    "name" : "getPurgeDelay",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getPurgeDelay",
    "returnType" : "java.lang.Long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the optional duration (in milliseconds) after which this tracker may be purged if it is actively\n processing messages (i.e., not idle or waiting).\n <p>\n This mechanism ensures that stale trackers are eventually cleaned up, particularly in scenarios where graceful\n disconnection is not guaranteed. This is especially relevant for <i>external trackers</i> — such as non-Java\n applications or clients not using the Fluxzero Java SDK — which may not send an explicit disconnect.\n <p>\n For most Fluxzero applications, purging should rarely occur, as disconnection is managed by the Fluxzero Java SDK\n"
  }, {
    "name" : "getTrackerId",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getTrackerId",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the unique ID of this tracker instance.\n"
  }, {
    "name" : "getTypeFilter",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#getTypeFilter",
    "returnType" : "java.util.function.Predicate<java.lang.String>",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Returns a predicate for filtering messages based on their type (class name).\n\n @return a type filter predicate. By default, allows all types.\n"
  }, {
    "name" : "hasMissedDeadline",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#hasMissedDeadline",
    "returnType" : "boolean",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return {@code true} if this tracker has missed its deadline.\n"
  }, {
    "name" : "ignoreSegment",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#ignoreSegment",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return {@code true} if this tracker ignores segment-based filtering (i.e. processes all segments).\n"
  }, {
    "name" : "isFilterMessageTarget",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#isFilterMessageTarget",
    "returnType" : "boolean",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return {@code true} if the tracker should only receive messages that explicitly target its client ID.\n <p>\n When enabled, this filter ensures that only {@link SerializedMessage messages} with a {@code target} matching\n {@link #getClientId()} are considered valid. This can be useful for isolating messages meant for a specific\n client.\n <p>\n When disabled (the default), all messages in the segment range are considered, regardless of their target.\n"
  }, {
    "name" : "isValidTarget",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#isValidTarget",
    "returnType" : "boolean",
    "modifiers" : [ "private" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "message",
      "type" : "io.fluxzero.common.api.SerializedMessage",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "segmentRange",
      "type" : "int[]",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Internal helper to check if this tracker is a valid target for a given {@link SerializedMessage} given the\n tracker's segment range.\n"
  }, {
    "name" : "isValidType",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#isValidType",
    "returnType" : "boolean",
    "modifiers" : [ "private" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "message",
      "type" : "io.fluxzero.common.api.SerializedMessage",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Internal helper to check type filter.\n"
  }, {
    "name" : "maxTimeout",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#maxTimeout",
    "returnType" : "long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return the maximum time window (in millis) after which a batch should be delivered even if no messages are\n available.\n"
  }, {
    "name" : "send",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#send",
    "returnType" : "void",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "batch",
      "type" : "io.fluxzero.common.api.tracking.MessageBatch",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Sends a batch of messages to this tracker.\n\n @param batch the batch to deliver\n"
  }, {
    "name" : "sendEmptyBatch",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#sendEmptyBatch",
    "returnType" : "void",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "batch",
      "type" : "io.fluxzero.common.api.tracking.MessageBatch",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Sends an empty batch (typically used to signal idle or shutdown). Default implementation forwards to\n {@link #send(MessageBatch)}.\n\n @param batch an empty batch instance\n"
  }, {
    "name" : "singleTracker",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#singleTracker",
    "returnType" : "boolean",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " @return {@code true} if this tracker is the only one allowed to handle messages for its consumer. This is useful\n for single-tracker consumer configurations.\n"
  }, {
    "name" : "withLastTrackerIndex",
    "qualifiedName" : "io.fluxzero.common.tracking.Tracker#withLastTrackerIndex",
    "returnType" : "io.fluxzero.common.tracking.Tracker",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "lastTrackerIndex",
      "type" : "java.lang.Long",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Returns a copy of this tracker with its last index updated.\n\n @param lastTrackerIndex the new index value\n @return a modified tracker instance\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
