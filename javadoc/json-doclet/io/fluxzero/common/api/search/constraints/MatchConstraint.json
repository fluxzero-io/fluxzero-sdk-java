{
  "name" : "MatchConstraint",
  "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint",
  "packageName" : "io.fluxzero.common.api.search.constraints",
  "kind" : "class",
  "modifiers" : [ "public" ],
  "annotations" : [ {
    "annotationType" : "lombok.Value",
    "values" : {}
  }, {
    "annotationType" : "lombok.AllArgsConstructor",
    "values" : {
      "access" : "PRIVATE"
    }
  } ],
  "documentation" : " A constraint that matches indexed document values based on text equality or normalized phrase matching.\n <p>\n The {@code MatchConstraint} is commonly used to filter documents that contain a specific word, phrase, or exact value\n in one or more indexed fields.\n </p>\n\n <h2>Examples</h2>\n <pre>{@code\n // Match documents where the \"status\" field is \"open\"\n Constraint constraint = MatchConstraint.match(\"open\", \"status\");\n\n // Match across all indexed fields\n Constraint constraint = MatchConstraint.match(\"open\");\n\n // Match across multiple fields with strict equality\n Constraint constraint = MatchConstraint.match(\"PENDING\", true, \"status\", \"state\");\n }</pre>\n\n <h2>Path Handling</h2>\n You can provide one or more paths to target specific fields in the document. If no paths are provided, the constraint\n will match anywhere in the document. Empty or null paths are filtered out automatically.\n\n <h2>Matching Modes</h2>\n The constraint supports two modes:\n <ul>\n     <li>{@code strict = true} – uses exact string equality against the raw value of the entry.</li>\n     <li>{@code strict = false} (default) – uses normalized matching via {@link SearchUtils#normalize(String)}\n         and compares to the {@code asPhrase()} form of the entry (used for full-text search).</li>\n </ul>\n\n @see PathConstraint\n @see AnyConstraint\n @see SearchUtils#normalize(String)\n",
  "typeParameters" : [ ],
  "superClass" : "io.fluxzero.common.api.search.constraints.PathConstraint",
  "interfaces" : [ ],
  "fields" : [ {
    "name" : "entryMatcher",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint.entryMatcher",
    "type" : "java.util.function.Predicate<io.fluxzero.common.search.Document.Entry>",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.Getter",
      "values" : {
        "lazy" : "true",
        "value" : "PROTECTED"
      }
    }, {
      "annotationType" : "lombok.experimental.Accessors",
      "values" : {
        "fluent" : "true"
      }
    }, {
      "annotationType" : "lombok.EqualsAndHashCode.Exclude",
      "values" : {}
    } ],
    "documentation" : null,
    "constantValue" : null
  }, {
    "name" : "match",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint.match",
    "type" : "java.lang.@lombok.NonNull String",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.NonNull",
      "values" : {}
    } ],
    "documentation" : null,
    "constantValue" : null
  }, {
    "name" : "paths",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint.paths",
    "type" : "java.util.List<java.lang.String>",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.With",
      "values" : {}
    } ],
    "documentation" : null,
    "constantValue" : null
  }, {
    "name" : "strict",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint.strict",
    "type" : "boolean",
    "modifiers" : [ ],
    "annotations" : [ ],
    "documentation" : null,
    "constantValue" : null
  } ],
  "constructors" : [ {
    "name" : "MatchConstraint",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint#MatchConstraint",
    "modifiers" : [ "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : null
  } ],
  "methods" : [ {
    "name" : "computeEntryMatcher",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint#computeEntryMatcher",
    "returnType" : "java.util.function.Predicate<io.fluxzero.common.search.Document.Entry>",
    "modifiers" : [ "protected" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : null
  }, {
    "name" : "match",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint#match",
    "returnType" : "io.fluxzero.common.api.search.Constraint",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "value",
      "type" : "java.lang.Object",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "strict",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "paths",
      "type" : "java.lang.String[]",
      "varArgs" : true,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : true,
    "documentation" : " Creates a constraint that matches the given value across the specified paths, with an option to enforce strict\n string equality.\n <p>\n If no paths are given, the match will be applied across all indexed fields in the document.\n <p>\n If the value is {@code null}, returns a {@link NoOpConstraint}. If the value is a {@link Collection}, creates a\n disjunction ({@link AnyConstraint}) of match constraints for each non-null element. If the value implements\n {@link HasId}, the {@code getId()} value is used for matching. For all other types, the value is converted to a\n string.\n\n @param value  the value to match\n @param strict if {@code true}, use exact string matching; if {@code false}, use normalized phrase match\n @param paths  the paths to search in (or empty for all fields)\n @return a {@link Constraint} instance or {@link NoOpConstraint}\n"
  }, {
    "name" : "match",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint#match",
    "returnType" : "io.fluxzero.common.api.search.Constraint",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "value",
      "type" : "java.lang.Object",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "paths",
      "type" : "java.lang.String[]",
      "varArgs" : true,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : true,
    "documentation" : " Creates a constraint that performs non-strict (normalized) matching of the provided value across the specified\n paths.\n <p>\n If no paths are given, the match will be applied across all indexed fields in the document.\n <p>\n If the value is {@code null}, returns a {@link NoOpConstraint}. If the value is a {@link Collection}, creates a\n disjunction ({@link AnyConstraint}) of match constraints for each non-null element. If the value implements\n {@link HasId}, the {@code getId()} value is used for matching. For all other types, the value is converted to a\n string.\n\n @param value the value to match\n @param paths the paths to search in (or empty for all fields)\n @return a {@link Constraint} instance or {@link NoOpConstraint}\n"
  }, {
    "name" : "matches",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.MatchConstraint#matches",
    "returnType" : "boolean",
    "modifiers" : [ "protected" ],
    "annotations" : [ {
      "annotationType" : "java.lang.Override",
      "values" : {}
    } ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "entry",
      "type" : "io.fluxzero.common.search.Document.Entry",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "document",
      "type" : "io.fluxzero.common.search.Document",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : null
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
