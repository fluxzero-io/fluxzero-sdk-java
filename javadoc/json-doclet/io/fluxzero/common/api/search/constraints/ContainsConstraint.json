{
  "name" : "ContainsConstraint",
  "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint",
  "packageName" : "io.fluxzero.common.api.search.constraints",
  "kind" : "class",
  "modifiers" : [ "public" ],
  "annotations" : [ {
    "annotationType" : "lombok.Value",
    "values" : {}
  }, {
    "annotationType" : "lombok.AllArgsConstructor",
    "values" : {
      "access" : "PRIVATE"
    }
  } ],
  "documentation" : " A constraint that matches document entries containing the specified phrase, with optional wildcard-like flexibility.\n\n <p>This constraint can simulate different types of text searches based on the configuration:\n\n <ul>\n     <li>{@code prefixSearch = true}:\n         Matches entries that end with the phrase (e.g., {@code *day} matches \"Monday\", \"Tuesday\").</li>\n     <li>{@code postfixSearch = true}:\n         Matches entries that start with the phrase (e.g., {@code mon*} matches \"Monday\", \"Monster\").</li>\n     <li>Both {@code prefixSearch} and {@code postfixSearch}:\n         Matches entries that contain the phrase anywhere (e.g., {@code *mon*} matches \"Monday\", \"Common\", \"Commoner\").</li>\n     <li>Both {@code prefixSearch} and {@code postfixSearch} disabled (default):\n         Matches the full word exactly as it appears (normalized and case-insensitive).</li>\n </ul>\n\n <p>If {@code splitInTerms} is true, the input phrase is split into individual normalized terms, and each term is\n matched independently using the same search behavior. All terms must be found in the same document entry for the\n match to succeed.\n <p>\n Matching is performed against the normalized form of each document entry using regular expressions if filtering is\n done in-memory. When using Fluxzero Runtime, this constraint is evaluated directly within the backing data store\n whenever possible.\n\n <p>If no paths are provided, the constraint matches all paths within the document.</p>\n\n <h2>Performance Considerations</h2>\n <ul>\n     <li>\n         Terms using a <strong>prefix</strong> or <strong>postfix</strong> wildcard (e.g., {@code user*} or {@code *name}) are resolved at the data store level and typically fast.\n     </li>\n     <li>\n         Terms using <strong>both prefix and postfix</strong> wildcards (e.g., {@code *log*}) are not natively supported by the backend and require <strong>in-memory filtering</strong>, which can be slow for large result sets.\n     </li>\n     <li>\n         <strong>Similarly, prefix or postfix matches with terms shorter than 3 characters</strong> are also evaluated in-memory.\n         <br>\n         <em>Note:</em> This limitation does <strong>not</strong> apply to complete word matches (i.e., without wildcards).\n         For example, {@code \"to\"} as an exact term is efficient, but {@code to*} or {@code *to} are not.\n     </li>\n     <li>\n         When possible, prefer longer terms and structure queries to enable efficient execution via the underlying document store.\n     </li>\n </ul>\n\n @see PathConstraint\n @see LookAheadConstraint\n @see QueryConstraint\n",
  "typeParameters" : [ ],
  "superClass" : "io.fluxzero.common.api.search.constraints.PathConstraint",
  "interfaces" : [ ],
  "fields" : [ {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint.contains",
    "type" : "java.lang.@lombok.NonNull String",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.NonNull",
      "values" : {}
    } ],
    "documentation" : " The normalized string to match within document entries.\n",
    "constantValue" : null
  }, {
    "name" : "paths",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint.paths",
    "type" : "java.util.List<java.lang.String>",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.With",
      "values" : {}
    } ],
    "documentation" : " The list of paths in the document to restrict matching to. If left empty, the match applies to all paths.\n",
    "constantValue" : null
  }, {
    "name" : "pattern",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint.pattern",
    "type" : "java.util.regex.Pattern",
    "modifiers" : [ ],
    "annotations" : [ {
      "annotationType" : "lombok.Getter",
      "values" : {
        "lazy" : "true",
        "value" : "PROTECTED"
      }
    }, {
      "annotationType" : "lombok.experimental.Accessors",
      "values" : {
        "fluent" : "true"
      }
    }, {
      "annotationType" : "lombok.EqualsAndHashCode.Exclude",
      "values" : {}
    } ],
    "documentation" : " A compiled regex pattern used to match terms inside the normalized document content.\n <p>\n This pattern is lazily constructed using the normalized form of {@link #getContains()}, and it respects the\n {@link #prefixSearch} and {@link #postfixSearch} flags to anchor matching at term boundaries.\n",
    "constantValue" : null
  }, {
    "name" : "postfixSearch",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint.postfixSearch",
    "type" : "boolean",
    "modifiers" : [ ],
    "annotations" : [ ],
    "documentation" : " If {@code true}, matches any word or phrase that starts with the given term.\n <p>For example, with {@code contains = \"mon\"}, this would match \"Monday\", \"Monster\", etc.\n <p>Use this to simulate a {@code term*} search.\n",
    "constantValue" : null
  }, {
    "name" : "prefixSearch",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint.prefixSearch",
    "type" : "boolean",
    "modifiers" : [ ],
    "annotations" : [ ],
    "documentation" : " If {@code true}, matches any word or phrase that ends with the given term.\n <p>For example, with {@code contains = \"day\"}, this would match \"Monday\", \"Tuesday\", etc.\n <p>Use this to simulate a {@code *term} search.\n",
    "constantValue" : null
  } ],
  "constructors" : [ {
    "name" : "ContainsConstraint",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint#ContainsConstraint",
    "modifiers" : [ "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : null
  } ],
  "methods" : [ {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint#contains",
    "returnType" : "io.fluxzero.common.api.search.Constraint",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "phrase",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "prefixSearch",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "postfixSearch",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "splitInTerms",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "paths",
      "type" : "java.lang.String[]",
      "varArgs" : true,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : true,
    "documentation" : " Create a constraint that optionally splits the input phrase into individual terms and combines the resulting\n constraints using {@link AllConstraint}.\n <p>\n This is especially useful when you want all words in a multi-word search query to be matched.\n\n @param phrase        the full phrase to optionally split and match\n @param prefixSearch  whether to allow entries that end with the phrase, e.g.: *hat\n @param postfixSearch whether to allow entries that start with the phrase, e.g.: hat*\n @param splitInTerms  if {@code true}, splits the phrase into individual normalized terms\n @param paths         optional field paths to restrict the match\n @return a compound {@link AllConstraint} if multiple terms, or a single {@code ContainsConstraint}\n"
  }, {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint#contains",
    "returnType" : "io.fluxzero.common.api.search.Constraint",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "phrase",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "prefixSearch",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "postfixSearch",
      "type" : "boolean",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "paths",
      "type" : "java.lang.String[]",
      "varArgs" : true,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : true,
    "documentation" : " Create a constraint that allows prefix and/or postfix matching of a given phrase.\n <p>\n This provides fine-grained control over how terms are matched:\n <ul>\n   <li>{@code prefixSearch = true}: allows matches at the start of words</li>\n   <li>{@code postfixSearch = true}: allows matches at the end of words</li>\n </ul>\n\n @param phrase        the phrase to match\n @param prefixSearch  whether to allow entries that end with the phrase, e.g.: *hat\n @param postfixSearch whether to allow entries that start with the phrase, e.g.: hat*\n @param paths         optional field paths to restrict the match to\n @return a {@code Constraint} using the specified match settings\n"
  }, {
    "name" : "contains",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint#contains",
    "returnType" : "io.fluxzero.common.api.search.Constraint",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "phrase",
      "type" : "java.lang.String",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "paths",
      "type" : "java.lang.String[]",
      "varArgs" : true,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : true,
    "documentation" : " Create a basic {@code ContainsConstraint} that checks if the given phrase exists anywhere in the entry, using\n default full-word matching (i.e., neither prefix nor postfix logic).\n\n @param phrase the phrase to match\n @param paths  optional field paths to restrict the search to\n @return a {@code Constraint} that matches if the phrase is found\n"
  }, {
    "name" : "matches",
    "qualifiedName" : "io.fluxzero.common.api.search.constraints.ContainsConstraint#matches",
    "returnType" : "boolean",
    "modifiers" : [ "protected" ],
    "annotations" : [ {
      "annotationType" : "java.lang.Override",
      "values" : {}
    } ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "entry",
      "type" : "io.fluxzero.common.search.Document.Entry",
      "varArgs" : false,
      "annotations" : [ ]
    }, {
      "name" : "document",
      "type" : "io.fluxzero.common.search.Document",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Checks whether a single document entry matches the constraint. The entry is converted to a normalized phrase\n string, and the compiled regular expression is applied.\n\n @param entry the document entry\n @return {@code true} if the entry matches the pattern, otherwise {@code false}\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
