{
  "name" : "Consumer",
  "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer",
  "packageName" : "io.fluxzero.sdk.tracking",
  "kind" : "annotation_type",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ {
    "annotationType" : "java.lang.annotation.Retention",
    "values" : {
      "value" : "RUNTIME"
    }
  }, {
    "annotationType" : "java.lang.annotation.Target",
    "values" : {
      "value" : "TYPE,PACKAGE"
    }
  }, {
    "annotationType" : "java.lang.annotation.Inherited",
    "values" : {}
  }, {
    "annotationType" : "java.lang.annotation.Documented",
    "values" : {}
  } ],
  "documentation" : " Declares a {@code Consumer} within a Fluxzero application.\n <p>\n A consumer represents an isolated group of handlers that independently track and process messages from one or more\n message logs. It can be applied at the class or package level to group handlers together. Handlers that do not\n explicitly declare a {@code Consumer} are assigned according to the application's configuration, as defined via\n {@link FluxzeroBuilder#addConsumerConfiguration(ConsumerConfiguration, MessageType...)} )}. If no specific\n configuration is provided, the handler will be assigned to the application's default consumer.\n </p>\n\n <p>\n A consumer consists of one or more <em>trackers</em>—individual threads or processes that fetch and process message\n segments. Each tracker is responsible for a disjoint segment of the message log, allowing for parallel consumption.\n By default, messages are sharded into 128 segments; a consumer with {@code threads = 2} will assign 64 segments to\n each tracker.\n </p>\n\n <p>\n This annotation offers fine-grained control over message processing characteristics including concurrency, batching,\n backpressure, result publication, and handler exclusivity.\n </p>\n\n <h2>Terminology</h2>\n <ul>\n   <li><strong>Consumer</strong>: Named group of handlers with isolated message tracking state.</li>\n   <li><strong>Tracker</strong>: A processing thread assigned to a specific segment of the message log.</li>\n   <li><strong>Handler</strong>: Method annotated with {@code @HandleEvent}, {@code @HandleCommand}, etc., which processes messages.</li>\n </ul>\n\n <h2>Example:</h2>\n <pre>{@code\n @Consumer(name = \"audit\", threads = 3, passive = true)\n class AuditHandler {\n     @HandleCommand\n     void on(AuthenticateUser command) {\n         // log for auditing; result will not be published due to passive = true\n     }\n }\n }</pre>\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ "java.lang.annotation.Annotation" ],
  "fields" : [ ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "batchInterceptors",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#batchInterceptors",
    "returnType" : "java.lang.Class<? extends io.fluxzero.sdk.tracking.BatchInterceptor>[]",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Interceptors applied at the batch level across all messages in a poll cycle.\n"
  }, {
    "name" : "clientControlledIndex",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#clientControlledIndex",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " If {@code true}, the consumer will not rely on Fluxzero's internal tracking index. Instead, the application itself is\n responsible for determining which messages to process.\n <p>\n This is typically used in combination with {@link #ignoreSegment()} set to {@code true} to ensure that all\n application instances receive every message—rather than a sharded subset.\n </p>\n\n <p>\n This mode is useful for scenarios where message delivery must be broadcast to all instances. For example, a\n WebSocket endpoint that pushes updates to connected clients may need to observe the full message stream, ensuring\n that each client sees every relevant update.\n </p>\n\n <p>\n When {@code false} (the default), Fluxzero tracks message indices and distributes segments to consumer trackers\n for balanced parallel processing.\n </p>\n"
  }, {
    "name" : "durationUnit",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#durationUnit",
    "returnType" : "java.time.temporal.ChronoUnit",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Unit for {@link #maxWaitDuration()}. Default is {@link ChronoUnit#SECONDS}.\n"
  }, {
    "name" : "errorHandler",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#errorHandler",
    "returnType" : "java.lang.Class<? extends io.fluxzero.sdk.tracking.ErrorHandler>",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Error handler invoked when a message processing error occurs. Default is {@link LoggingErrorHandler} which logs\n errors and allows message tracking and processing to continue.\n"
  }, {
    "name" : "exclusive",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#exclusive",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Determines whether handlers assigned to this consumer are excluded from other consumers.\n <p>\n If {@code true} (default), a handler will only be active in this consumer.\n If {@code false}, the same handler may be active in multiple consumers simultaneously.\n This enables advanced scenarios such as parallel replays alongside live processing.\n </p>\n"
  }, {
    "name" : "filterMessageTarget",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#filterMessageTarget",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " If {@code true}, only messages explicitly targeted at this application instance will be processed. Typically used\n for tracking of {@code Result} or {@code WebResponse} messages. If {@code true}, this consumer will only receive\n results targeted for this application instance.\n"
  }, {
    "name" : "flowRegulator",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#flowRegulator",
    "returnType" : "java.lang.Class<? extends io.fluxzero.sdk.tracking.FlowRegulator>",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Regulates message flow and backpressure behavior. Default is {@link NoOpFlowRegulator}.\n"
  }, {
    "name" : "handlerInterceptors",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#handlerInterceptors",
    "returnType" : "java.lang.Class<? extends io.fluxzero.sdk.tracking.handling.HandlerInterceptor>[]",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Interceptors applied to individual handler method invocations.\n"
  }, {
    "name" : "ignoreSegment",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#ignoreSegment",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " If {@code true}, this consumer will bypass the default segment-based sharding applied by the Fluxzero Runtime and\n attempt to process all message segments.\n <p>\n By default, Fluxzero shards messages across consumers using a routing key present in the message payload, or the\n message ID if no routing key is specified. However, some handlers may require a custom sharding strategy— for\n instance, sharding based on a different property in the payload.\n </p>\n\n <p>\n Setting {@code ignoreSegment = true} allows such handlers to override Fluxzero's internal routing and apply their own\n logic. A common pattern is to use the {@code @RoutingKey} annotation on a handler method to specify a custom\n property:\n </p>\n\n <pre>{@code\n @HandleEvent\n @RoutingKey(\"organisationId\")\n void handle(CreateUser event) {\n     // process based on organisationId instead of the default routing key\n }\n }</pre>\n"
  }, {
    "name" : "maxFetchSize",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#maxFetchSize",
    "returnType" : "int",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Maximum number of messages to fetch in a batch. Default is {@code 1024}.\n"
  }, {
    "name" : "maxIndexExclusive",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#maxIndexExclusive",
    "returnType" : "long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Optional exclusive upper bound for message processing. Messages at or above this index will not be processed.\n Ignored if negative.\n"
  }, {
    "name" : "maxWaitDuration",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#maxWaitDuration",
    "returnType" : "long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Maximum time to wait before fetching a new batch, when none are available. See {@link #durationUnit()} for the\n time unit. Default is {@code 60} (seconds).\n"
  }, {
    "name" : "minIndex",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#minIndex",
    "returnType" : "long",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Optional minimum message index from which this consumer should begin processing.\n <p>\n If set to a non-negative value, only messages at or above this index will be processed. If negative (the\n default), the consumer will start processing from the current end of the message log – i.e., it will only receive\n new messages from this point forward.\n </p>\n"
  }, {
    "name" : "name",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#name",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " The unique name of the consumer. Required. This isolates its tracking tokens from other consumers.\n"
  }, {
    "name" : "passive",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#passive",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Indicates that this consumer should process messages without publishing result messages.\n <p>\n When {@code true}, return values from request handlers (e.g., {@code @HandleCommand}, {@code @HandleQuery},\n {@code @HandleWebRequest}) are ignored and not appended to the result log. This is useful for secondary consumers\n that perform side-effects or projections without impacting the result flow.\n"
  }, {
    "name" : "singleTracker",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#singleTracker",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " If {@code true}, designates a single tracker within this consumer as the \"main\" tracker, responsible for\n processing all messages across all segments.\n <p>\n Although multiple tracker threads may be configured (via {@link #threads()}), only one tracker will be assigned\n all segments. Other trackers will remain idle and receive no segment assignments.\n </p>\n\n <p>\n This setting is useful when:\n <ul>\n   <li>Messages must be processed strictly in global index order by a single process.</li>\n   <li>No suitable routing key exists for meaningful partitioning.</li>\n   <li>Handler logic requires a holistic or stateful view of all messages across the log.</li>\n </ul>\n\n <p>\n In contrast to regular segmented consumers, this mode disables concurrent processing\n across trackers but ensures strict ordering.\n </p>\n"
  }, {
    "name" : "storePositionManually",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#storePositionManually",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Whether this consumer is taking manual control over storing its position in the log.\n <p>\n When {@code true}, the consumer is responsible for explicitly storing its position after processing one or more\n message batches. This allows for greater control — for example, when handling long-running workflows that span\n multiple batches, or when committing position should be deferred until post-processing is complete.\n <p>\n When {@code false} (the default), the position is automatically updated after each message batch is processed,\n ensuring progress is recorded and avoiding reprocessing on restart.\n <p>\n Note: Even with manual position tracking enabled, the consumer will continue to receive \"new\" messages as long as\n the tracking process remains active. However, its persisted position will not be updated unless explicitly stored.\n"
  }, {
    "name" : "threads",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#threads",
    "returnType" : "int",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " The number of tracker threads to allocate for this consumer. Each thread processes a unique segment of the\n message log. Default is {@code 1}.\n"
  }, {
    "name" : "typeFilter",
    "qualifiedName" : "io.fluxzero.sdk.tracking.Consumer#typeFilter",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Optional regular expression used to filter message payload types on the Fluxzero Runtime.\n <p>\n When specified, this filter is applied server-side to restrict the messages delivered to the consumer based on\n the fully qualified type name of the payload.\n </p>\n\n <p>\n If left empty (the default), all message types are delivered to the client, and filtering is performed locally by\n the handlers. This is typically the preferred approach, as it avoids tightly coupling consumer configuration to\n type naming and allows for greater flexibility.\n </p>\n\n <p>\n Example: {@code typeFilter = \".*\\\\.CreateUser$|.*\\\\.UpdateUser$\"} matches any {@code CreateUser} or\n {@code UpdateUser} message types, regardless of package. This is useful for selectively tracking a set of message\n types without tying the filter to specific namespaces.\n </p>\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
