{
  "name" : "HandlerDecorator",
  "qualifiedName" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator",
  "packageName" : "io.fluxzero.sdk.tracking.handling",
  "kind" : "interface",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ {
    "annotationType" : "java.lang.FunctionalInterface",
    "values" : {}
  } ],
  "documentation" : " Functional interface for decorating {@link Handler} instances that process {@link DeserializingMessage} objects.\n <p>\n A {@code HandlerDecorator} is used to wrap a handler with additional behavior. This provides a flexible mechanism for\n implementing cross-cutting concerns such as authorization, metrics, context propagation, or logging.\n </p>\n\n <p>\n Unlike {@link HandlerInterceptor}, which focuses on message-level interception, a {@code HandlerDecorator} wraps the\n entire handler object and can be applied at a higher levelâ€”for example, before handler resolution occurs.\n </p>\n\n <h2>Composition</h2>\n <p>\n Decorators can be chained using {@link #andThen(HandlerDecorator)}, allowing multiple layers of behavior to be\n composed in a defined order.\n </p>\n\n <h2>Example:</h2>\n <pre>{@code\n public class MetricsDecorator implements HandlerDecorator {\n     @Override\n     public Handler<DeserializingMessage> wrap(Handler<DeserializingMessage> handler) {\n         return new Handler<>() {\n             @Override\n             public Optional<HandlerInvoker> getInvoker(DeserializingMessage message) {\n                 return handler.getInvoker(message);\n             }\n\n             @Override\n             public Class<?> getTargetClass() {\n                 return handler.getTargetClass();\n             }\n\n             @Override\n             public Object invoke(BiFunction<Object, Object, Object> combiner) {\n                 long start = System.nanoTime();\n                 Object result = handler.getInvoker(message).orElseThrow().invoke(combiner);\n                 metrics.recordLatency(System.nanoTime() - start);\n                 return result;\n             }\n         };\n     }\n }\n }</pre>\n\n @see HandlerInterceptor\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ ],
  "fields" : [ {
    "name" : "noOp",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator.noOp",
    "type" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator",
    "modifiers" : [ "final", "public", "static" ],
    "annotations" : [ ],
    "documentation" : " A no-op decorator that returns the original handler unmodified.\n",
    "constantValue" : null
  } ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "andThen",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator#andThen",
    "returnType" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator",
    "modifiers" : [ "default", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "next",
      "type" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Chains this decorator with another, producing a composite decorator.\n <p>\n The {@code next} decorator is applied first, followed by this decorator.\n\n @param next the decorator to apply before this one\n @return a combined {@code HandlerDecorator}\n"
  }, {
    "name" : "wrap",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator#wrap",
    "returnType" : "io.fluxzero.common.handling.Handler<io.fluxzero.sdk.common.serialization.DeserializingMessage>",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ {
      "name" : "handler",
      "type" : "io.fluxzero.common.handling.Handler<io.fluxzero.sdk.common.serialization.DeserializingMessage>",
      "varArgs" : false,
      "annotations" : [ ]
    } ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Wraps the given handler with additional behavior.\n\n @param handler the original handler to be wrapped\n @return a decorated handler\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ {
    "name" : "MergedDecorator",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.HandlerDecorator$MergedDecorator",
    "kind" : "class",
    "modifiers" : [ "public", "static" ],
    "annotations" : [ {
      "annotationType" : "lombok.AllArgsConstructor",
      "values" : {}
    } ]
  } ]
}
