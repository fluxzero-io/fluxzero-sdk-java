{
  "name" : "Stateful",
  "qualifiedName" : "io.fluxzero.sdk.tracking.handling.Stateful",
  "packageName" : "io.fluxzero.sdk.tracking.handling",
  "kind" : "annotation_type",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ {
    "annotationType" : "java.lang.annotation.Documented",
    "values" : {}
  }, {
    "annotationType" : "java.lang.annotation.Target",
    "values" : {
      "value" : "TYPE"
    }
  }, {
    "annotationType" : "java.lang.annotation.Retention",
    "values" : {
      "value" : "RUNTIME"
    }
  }, {
    "annotationType" : "java.lang.annotation.Inherited",
    "values" : {}
  }, {
    "annotationType" : "io.fluxzero.sdk.persisting.search.Searchable",
    "values" : {}
  }, {
    "annotationType" : "org.springframework.stereotype.Component",
    "values" : {}
  }, {
    "annotationType" : "org.springframework.context.annotation.Scope",
    "values" : {
      "value" : "prototype"
    }
  } ],
  "documentation" : " Declares that a class is a stateful message handler — i.e., one whose state is persisted and which can receive\n messages via {@link Association}.\n <p>\n Stateful handlers are used to model long-lived processes or external interactions (e.g. async API flows, payments,\n inboxes). These handlers are typically stored and restored across messages and retain their internal state.\n\n <h2>Handler Activation</h2>\n When a message matches one or more handlers (via {@link Association}), all matching handlers are:\n <ul>\n     <li>Loaded from storage (usually the search index)</li>\n     <li>And invoked via matching {@code @Handle...} methods.</li>\n </ul>\n <p>\n A single message may invoke <strong>multiple matching stateful handlers</strong>.\n\n <h2>Persistence</h2>\n Handler state is persisted via a {@link HandlerRepository}.\n By default, the {@link io.fluxzero.sdk.persisting.search.DocumentStore} is used.\n <ul>\n     <li>The identifier of a handler is derived from an {@link EntityId} property or auto-generated if absent.</li>\n     <li>Handlers are immutable by convention and updated using {@code withX(...)} methods.</li>\n </ul>\n\n <h3>Basic Example</h3>\n <pre>{@code\n @Value\n @Stateful\n public class PaymentProcess {\n     @EntityId String id;\n     @Association String pspReference;\n     PaymentStatus status;\n\n     @HandleEvent\n     static PaymentProcess on(PaymentInitiated event) {\n         String pspReference = Fluxzero.sendCommandAndWait(new ExecutePayment(...));\n         return new PaymentProcess(event.getPaymentId(), pspReference, PaymentStatus.PENDING);\n     }\n\n     @HandleEvent\n     PaymentProcess on(PaymentConfirmed event) {\n         return withStatus(PaymentStatus.CONFIRMED);\n     }\n }\n }</pre>\n\n <h3>Deleting a stateful handler</h3>\n If a handler method returns {@code null}, the instance is removed from its persistence store.\n This can be useful for modeling short-lived processes or sagas that end upon receiving a terminal event.\n\n <pre>{@code\n @HandleEvent\n PaymentProcess on(PaymentFailed event) {\n     return null; // Delete this handler\n }\n }</pre>\n\n <h3>Type constraints on handler updates</h3>\n State changes to a {@code @Stateful} handler are only applied if the method returns a value that is\n assignable to the handler's class type. For example:\n\n <ul>\n     <li>If the method returns {@code void}, no update occurs.</li>\n     <li>If the method returns a value that is unrelated to the handler type, the return value is ignored for state updates.</li>\n </ul>\n\n <p>\n This makes it safe to return primitive types or utility values from handler methods without risk of\n overwriting the handler state. For instance:\n\n <pre>{@code\n @HandleSchedule\n Duration on(CheckPaymentStatus schedule) {\n     PaymentStatus status = Fluxzero.queryAndWait(new CheckStatus(schedule.getPaymentId()));\n     if (status == COMPLETED) {\n         return null; // stop scheduling\n     }\n     return Duration.ofMinutes(1); // retry in 1 minute\n }\n }</pre>\n\n <p>\n In this example, returning a {@code Duration} controls the rescheduling behavior, but it does not affect the stored\n state of the {@code PaymentProcess} handler.\n\n <h2>Search Indexing</h2>\n Like aggregates, {@code @Stateful} handlers are also {@link Searchable} and can be indexed automatically:\n <ul>\n     <li>{@link #collection()} defines the search collection name</li>\n     <li>{@link #timestampPath()} and {@link #endPath()} define time bounds for filtering</li>\n </ul>\n\n <h2> Tracking Isolation</h2>\n {@code @Stateful} handlers may optionally include a {@link io.fluxzero.sdk.tracking.Consumer} annotation\n to define their own tracking configuration (e.g. isolation, concurrency, retry policy).\n\n @see Association\n @see EntityId\n @see io.fluxzero.sdk.tracking.Consumer\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ "java.lang.annotation.Annotation" ],
  "fields" : [ ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "collection",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.Stateful#collection",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Name of the collection in which the stateful handler instance will be stored.\n <p>\n Defaults to the simple class name (e.g., {@code PaymentProcess} → {@code paymentProcess}).\n\n @see Searchable\n"
  }, {
    "name" : "commitInBatch",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.Stateful#commitInBatch",
    "returnType" : "boolean",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Determines whether the state changes to this handler should be committed at the end of the current message batch\n (if applicable), or immediately after the message that triggered the change (default behavior).\n <p>\n If set to {@code true}, changes are deferred and committed once all messages in the current batch have been\n processed. This is particularly useful for reducing round-trips to the underlying persistence store when applying\n lots of updates.\n\n <h4>Association behavior with deferred commits</h4>\n Even though the state is not yet persisted when {@code commitInBatch} is {@code true}, the message routing logic\n remains accurate and consistent. This is achieved by maintaining a local cache of uncommitted changes.\n <p>\n The cache is used to:\n <ul>\n     <li>Ensure that newly created handlers can be matched to later messages in the same batch.</li>\n     <li>Prevent messages from being routed to handlers that have been deleted earlier in the batch.</li>\n     <li>Use the most recent (updated) state when evaluating associations for subsequent messages.</li>\n </ul>\n <p>\n In other words, association lookups during batch processing always take into account:\n <ul>\n     <li>The persisted state (from the backing repository), and</li>\n     <li>The in-memory cache of batch-local updates (created, updated, or deleted handlers).</li>\n </ul>\n <p>\n This guarantees consistent and predictable behavior within the boundaries of the current batch, even when the\n persistent state has not yet been flushed.\n\n <h4>Note:</h4>\n If no current batch is active (e.g. in synchronous or local usage), changes are always committed immediately,\n regardless of this setting.\n"
  }, {
    "name" : "endPath",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.Stateful#endPath",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Optional path to extract an end timestamp for search indexing.\n <p>\n If omitted, the start timestamp will also be used as the end timestamp.\n\n @see Searchable\n"
  }, {
    "name" : "timestampPath",
    "qualifiedName" : "io.fluxzero.sdk.tracking.handling.Stateful#timestampPath",
    "returnType" : "java.lang.String",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Path to extract the main timestamp used in search indexing.\n <p>\n If {@link #endPath()} is not specified, this will be used as both start and end time.\n <p>\n Useful for time-based search queries (e.g., validity or activity windows).\n\n @see Searchable\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
