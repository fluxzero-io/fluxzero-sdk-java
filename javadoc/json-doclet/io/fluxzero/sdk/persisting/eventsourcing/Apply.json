{
  "name" : "Apply",
  "qualifiedName" : "io.fluxzero.sdk.persisting.eventsourcing.Apply",
  "packageName" : "io.fluxzero.sdk.persisting.eventsourcing",
  "kind" : "annotation_type",
  "modifiers" : [ "abstract", "public" ],
  "annotations" : [ {
    "annotationType" : "java.lang.annotation.Documented",
    "values" : {}
  }, {
    "annotationType" : "java.lang.annotation.Retention",
    "values" : {
      "value" : "RUNTIME"
    }
  }, {
    "annotationType" : "java.lang.annotation.Target",
    "values" : {
      "value" : "METHOD,CONSTRUCTOR"
    }
  } ],
  "documentation" : " Indicates that a method or constructor applies an update to an entity, or creates or deletes an entity.\n <p>\n An {@code @Apply} method defines how a specific update modifies an entity. This update is typically the payload of a\n command or other message expressing intent. Once validated and applied, the update may be published and/or stored as\n an event, depending on the publication configuration.\n <p>\n {@code @Apply} can be placed:\n <ul>\n     <li>On a method inside the <strong>update class</strong> (e.g. {@code UpdateProduct#apply(Product)}),\n         which receives the current state of the entity and returns the updated version</li>\n     <li>On a method or static factory in the <strong>entity class</strong> itself\n         (e.g. {@code Product#update(UpdateProduct)}), which describes how the entity processes a given update</li>\n     <li>On a <strong>constructor</strong> or static method of the entity, if the update creates a new instance</li>\n </ul>\n <p>\n For deletions, returning {@code null} signals that the entity should be removed.\n <p>\n When the entity is part of a larger aggregate, Fluxzero automatically routes the update to the correct entity\n instance using matching identifier fields, typically annotated with {@link EntityId}.\n <p>\n {@code @Apply} methods are also used during event sourcing to reconstruct an entity's state from past updates.\n <p>\n Method parameters are injected automatically. Supported parameters include:\n <ul>\n     <li>The current entity instance (for non-static apply methods)</li>\n     <li>Any parent, grandparent, or other ancestor entity in the aggregate hierarchy</li>\n     <li>The update object itself</li>\n     <li>The full {@link io.fluxzero.sdk.common.Message} or its {@link io.fluxzero.common.api.Metadata}</li>\n     <li>Other context such as the {@link io.fluxzero.sdk.tracking.handling.authentication.User} performing the update</li>\n </ul>\n\n <p>\n Note that empty entities (where the value of the entity is {@code null}) are not injected unless the parameter\n is annotated with {@code @Nullable}.\n\n <h2>Examples</h2>\n\n <h3>1. Creating a new entity from an @Apply method inside the update class</h3>\n <pre>{@code\n @Apply\n Issue create() {\n     return Issue.builder()\n                 .issueId(issueId)\n                 .count(1)\n                 .status(IssueStatus.OPEN)\n                 .details(issueDetails)\n                 .firstSeen(lastSeen)\n                 .lastSeen(lastSeen)\n                 .build();\n }\n }</pre>\n\n <h3>2. Updating an entity with a new state</h3>\n <pre>{@code\n @Apply\n Product apply(Product product) {\n     return product.toBuilder().details(details).build();\n }\n }</pre>\n\n <h3>3. Deleting an entity</h3>\n <pre>{@code\n @Apply\n Product apply(Product product) {\n     return null;\n }\n }</pre>\n\n <h3>4. Defining apply methods inside the entity class</h3>\n <pre>{@code\n @Apply\n static Product create(CreateProduct update) {\n     return Product.builder()\n                   .productId(update.getProductId())\n                   .details(update.getDetails())\n                   .build();\n }\n\n @Apply\n Product update(UpdateProduct update) {\n     return this.toBuilder().details(update.getDetails()).build();\n }\n\n @Apply\n Product delete(DeleteProduct update) {\n     return null;\n }\n }</pre>\n\n <h4>Routing example with aggregates and nested entities</h4>\n <pre>{@code\n @Aggregate\n class ProductCategory {\n     String categoryId;\n\n     @Member\n     List<Product> products;\n }\n }</pre>\n Updates targeting `Product` will automatically be routed based on `@EntityId` inside `Product`.\n\n @see io.fluxzero.sdk.modeling.Aggregate\n @see EntityId\n @see io.fluxzero.sdk.modeling.Member\n @see EventPublication\n @see EventPublicationStrategy\n",
  "typeParameters" : [ ],
  "superClass" : null,
  "interfaces" : [ "java.lang.annotation.Annotation" ],
  "fields" : [ ],
  "constructors" : [ ],
  "methods" : [ {
    "name" : "eventPublication",
    "qualifiedName" : "io.fluxzero.sdk.persisting.eventsourcing.Apply#eventPublication",
    "returnType" : "io.fluxzero.sdk.modeling.EventPublication",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Controls whether the update should result in a published update, depending on whether the entity was actually\n modified.\n <p>\n This overrides the default from the enclosing aggregate, if set.\n\n @return update publication behavior\n"
  }, {
    "name" : "publicationStrategy",
    "qualifiedName" : "io.fluxzero.sdk.persisting.eventsourcing.Apply#publicationStrategy",
    "returnType" : "io.fluxzero.sdk.modeling.EventPublicationStrategy",
    "modifiers" : [ "abstract", "public" ],
    "annotations" : [ ],
    "typeParameters" : [ ],
    "parameters" : [ ],
    "thrownTypes" : [ ],
    "varArgs" : false,
    "documentation" : " Controls how the applied update is stored and/or published. This strategy takes precedence over\n {@link #eventPublication()} if explicitly set.\n\n @return strategy for persisting and/or publishing the applied update\n"
  } ],
  "enumConstants" : [ ],
  "recordComponents" : [ ],
  "nestedTypes" : [ ]
}
